<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
canvas {
    border:1px solid #d3d3d3;
    /*background-color: #111111;*/
    background-color: #ffffff;
    margin: auto;
    display: block;
}

div{
    display: block;
    margin: auto;
}

.hidden {
    display: none;
}

</style>
</head>
<body onload="startGame()">

<script>
var playerPiece;

//Constants
var playerWidth = 64;
var playerHeight = 64;
var playerMoveSpeed = 20;
var playerHealth = 100;

var bulletWidth = 8;
var bulletHeight = 8;
var bulletPower = 5;

var projectileWidth = 16;
var projectileHeight = 16;
var projectilePower = 10;

var spiderWidth = 210;
var spiderHeight = 230;

var b_spiderHealth = 250;
var m_spiderHealth = 125;
var s_spiderHeatlh = 75;

var areaWidth = 840;
var areaHeight = 840;
var areaBorder = 10;

var splashWidth = 840;
var splashHeight = 120;

var roundCount = 1;

// Note: Spider Ratio is 21 x 23

var playerEntities = [];    // Player created entities (i.e. Player Bullets)

var enemies = [];           // Enemies
var enemyEntities = [];     // Enemy created entities

function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
}

function spawn(){
    // console.log("kek");

    for(var i = 0; i < roundCount; i++){
        // console.log(i);

        var newEnemy = new component(spiderWidth, spiderHeight, "assets/large_spider.png", getRandomInt(areaBorder, areaWidth - (areaBorder + spiderWidth)), areaBorder, "lrg_spider");

        enemies.push(newEnemy);
    }
}

function startGame() {
    playerEntities = [];
    enemies = [];       
    enemyEntities = []; 

    playerPiece = new component(playerWidth, playerHeight, "assets/plane.png", areaWidth/2 - playerWidth/2, areaHeight - areaBorder, "player");

    var initialEnemy = new component(spiderWidth, spiderHeight, "assets/large_spider.png", areaWidth/2 - spiderWidth/2, areaBorder, "lrg_spider");

    enemies.push(initialEnemy);

    // playerPiece = new component(width, height, 'red', 420, 810);
    myGameArea.start();
}

var myGameArea = {
    canvas : document.createElement("canvas"),
    border : areaBorder,
    start : function() {
        this.canvas.width = areaWidth;
        this.canvas.height = areaHeight;
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
        this.frameNo = 0;
        this.interval = setInterval(updateGameArea, 20);
        window.addEventListener('keydown', function (e) {
            e.preventDefault();
            myGameArea.keys = (myGameArea.keys || []);
            myGameArea.keys[e.keyCode] = (e.type == "keydown");
        })
        window.addEventListener('keyup', function (e) {
            myGameArea.keys[e.keyCode] = (e.type == "keydown");
        })
    },
    stop : function() {
        clearInterval(this.interval);
    },    
    clear : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

function everyNthFrame(n) {
    if ((myGameArea.frameNo % n) == 0) {return true;}
    return false;
}

function everyInterval(n) {
    if ((myGameArea.frameNo % n) % 1 == 0) {return true;}
    return false;
}

function component(width, height, image, x, y, type) {
    this.type = type;
    // if (type == "image") {
        this.image = new Image();
        this.image.src = image;
    // }
    this.width = width;
    this.height = height;
    this.speedX = 0;
    this.speedY = 0;    
    this.x = x;
    this.y = y;

    this.health = 0;

    if(this.type === "player")
        this.health = playerHealth;
    else if(this.type === "bullet")
        this.health = bulletPower;
    else if(this.type === "lrg_spider")
        this.health = b_spiderHealth;
    else if(this.type === "med_spider")
        this.health = m_spiderHealth;
    else if(this.type === "sml_spider")
        this.health = s_spiderHeatlh;
    else if(this.type === "projectile")
        this.health = projectilePower;

    this.update = function() {
        ctx = myGameArea.context;

        /*

        Add image cycling code here.
        [use checkInterval() to determine when to cycle] 

        */


        // if (type == "image") {
        ctx.drawImage(this.image, 
            this.x, 
            this.y,
            this.width, this.height);
        // } else {
        //     ctx.fillStyle = color;
        //     ctx.fillRect(this.x, this.y, this.width, this.height);
        // }
    }

    this.newPos = function() {
        this.x += this.speedX;
        this.y -= this.speedY;

        if(this.x > myGameArea.canvas.width - this.width - myGameArea.border)
            this.x = myGameArea.canvas.width - this.width - myGameArea.border;
        if(this.x < 0 + myGameArea.border)
            this.x = 0 + myGameArea.border;

        if(this.y > myGameArea.canvas.height - this.height - myGameArea.border)
            this.y = myGameArea.canvas.height - this.height - myGameArea.border;
        if(this.y < 0 + myGameArea.border)
            this.y = 0 + myGameArea.border;
    }

    this.crashWith = function(otherobj) {
        var myleft = this.x;
        var myright = this.x + (this.width);
        var mytop = this.y;
        var mybottom = this.y + (this.height);
        var otherleft = otherobj.x;
        var otherright = otherobj.x + (otherobj.width);
        var othertop = otherobj.y;
        var otherbottom = otherobj.y + (otherobj.height);
        var crash = true;
        if ((mybottom < othertop) ||
               (mytop > otherbottom) ||
               (myright < otherleft) ||
               (myleft > otherright)) {
           crash = false;
        }

        if(crash)
            this.receiveDmg(otherobj);

        return crash;
    }

    this.receiveDmg = function( entity ) {
        /*

        Damage Calc here

        */

        if((this.type === "lrg_spider" || this.type === "med_spider" || this.type === "sml_spider")){
            if(entity.type === "bullet"){
                this.health -= entity.health;

                if(this.health < 0)
                    this.health = 0;
            }

            if(entity.type ==="player"){
                entity.health -= 25;

                if(entity.health < 0)
                    entity.health = 0;

                entity.speedX = 0;
                entity.speedY = 0;

                

                // if(entity.y - (entity.height*2) <= areaBorder || entity.y > this.y - this.height){
                //     if(this.x > areaWidth - (this.x + this.width)){
                //         entity.speedX = -entity.height;
                //     }
                //     else if(this.x < areaWidth - (this.x + this.width)){
                //         entity.speedX = entity.height;
                //     }
                // }
                
                if(!entity.health <= 0)
                    entity.speedY = -(entity.height*2);

                // entity.speedY = -entity.height;

                // entity.newPos();
                // entity.update();
            }
        }
        else if(this.type === "player"){
            /*

            Add Projectile code here

            */
            if(entity.type === "projectile"){
                this.health -= entity.health;

                if(this.health < 0)
                    this.health = 0;
            }
        }

    }
}

function cycleEntities(){
    for(x in playerEntities){
        playerEntities[x].speedY = 5;

        playerEntities[x].newPos();
        playerEntities[x].update();
        
        if(playerEntities[x].y <= 0 + myGameArea.border)
            playerEntities.splice(x, 1);
    }

    for(x in enemyEntities){
        enemyEntities[x].speedY = -5;

        enemyEntities[x].newPos();
        enemyEntities[x].update();
        
        if(enemyEntities[x].y >= areaHeight - myGameArea.border)
            enemyEntities.splice(x, 1);
    }

    for(x in enemies){
        var attackChance = getRandomInt(1, 100);

        if(attackChance % 4 == 0 && everyNthFrame(20)){
            enemyEntities.push(new component(projectileWidth, projectileHeight, "assets/projectile.png", enemies[x].x + ((enemies[x].width/2)), enemies[x].y + 100, "projectile"))
        }

        enemies[x].newPos();
        enemies[x].update();
    }
}

function checkCollision(){
    for(x in playerEntities){
        for(y in enemies){
            if(enemies[y].crashWith(playerEntities[x])){
                playerEntities.splice(x,1);
                break;
            }
        }
    }

    for(x in enemyEntities){
        if(playerPiece.crashWith(enemyEntities[x])){
            enemyEntities.splice(x,1);
        }
    }

    for(x in enemies){
        enemies[x].crashWith(playerPiece);
    }
}

function checkDeath(){
    if(playerPiece.health <= 0){
        return true;
    }

    for(x in enemies){
        if(enemies[x].health <= 0){
            if(enemies[x].type === "lrg_spider"){
                enemies.push(new component(enemies[x].width/2,enemies[x].height/2, "assets/medium_spider.png", enemies[x].x + (enemies[x].width/2), enemies[x].y, "med_spider"));
                enemies.push(new component(enemies[x].width/2,enemies[x].height/2, "assets/medium_spider.png", enemies[x].x + (enemies[x].width/2), enemies[x].y, "med_spider"));
            }
            if(enemies[x].type === "med_spider"){
                enemies.push(new component(enemies[x].width/2,enemies[x].height/2, "assets/small_spider.png", enemies[x].x + (enemies[x].width/2), enemies[x].y, "sml_spider"));
                enemies.push(new component(enemies[x].width/2,enemies[x].height/2, "assets/small_spider.png", enemies[x].x + (enemies[x].width/2), enemies[x].y, "sml_spider"));
            }

            enemies.splice(x, 1);
        }
    }

    return false;
}

function updateGameArea() {
    if(checkDeath()){
        //component(width, height, image, x, y, type)
        var gameOver = new component(splashWidth, splashHeight, "assets/gameover.png", 0, (areaHeight/2) - (splashHeight/2));

        // gameOver.newPos();
        gameOver.update();

        myGameArea.stop;

        if (myGameArea.keys && myGameArea.keys[32] ) {startGame()};
    }
    else{
        myGameArea.clear();
        myGameArea.frameNo += 1;
    
        playerPiece.moveAngle = 0;
        playerPiece.speedX = 0;
        playerPiece.speedY = 0;
    
        if (myGameArea.keys && myGameArea.keys[37]) {playerPiece.speedX = -playerMoveSpeed; }      // Left Arrow
        if (myGameArea.keys && myGameArea.keys[39]) {playerPiece.speedX = playerMoveSpeed; }       // Right Arrow
        if (myGameArea.keys && myGameArea.keys[38]) {playerPiece.speedY = playerMoveSpeed; }       // Up Arrow
        if (myGameArea.keys && myGameArea.keys[40]) {playerPiece.speedY = -playerMoveSpeed; }      // Down Arrow
    
        if (myGameArea.keys && myGameArea.keys[32] ) {                                 // Space Bar
            // component(width, height, image, x, y, type)
    
            if(everyNthFrame(10)){
                var bulletEntity = new component(bulletWidth, bulletHeight, "assets/bullet.png", playerPiece.x + ((playerPiece.width/2)), playerPiece.y + 1     , "bullet");
    
                playerEntities.push(bulletEntity);
            }
        }
    
        cycleEntities();
        checkCollision();
    
        // Reference: keycode.info
    
        playerPiece.newPos();
        playerPiece.update();
    }
}
</script>

<div><center>Make sure the gamearea has focus, and use the arrow keys to move around.</center></div>

</body>
</html>
